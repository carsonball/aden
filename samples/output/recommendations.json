{
  "analysisMetadata" : {
    "timestamp" : [ 2025, 9, 2, 18, 46, 14, 923154800 ],
    "dotnetFrameworkVersion" : "4.7.2",
    "entityFrameworkVersion" : "6.4.4",
    "totalEntitiesAnalyzed" : 6,
    "totalQueryPatternsFound" : 34
  },
  "migrationCandidates" : [ {
    "primaryEntity" : "Customer",
    "relatedEntities" : [ "Order", "Orders", "OrderItem", "CustomerProfile", "Profile" ],
    "complexity" : "LOW",
    "score" : 190,
    "reason" : "Eager loading patterns (3 occurrences); Always loaded with: Orders, Profile; Read-heavy access pattern (ratio: 5.0:1); Complex eager loading patterns (1 complex queries)",
    "currentPattern" : {
      "eagerLoadingFrequency" : 3,
      "readWriteRatio" : 5.0,
      "averageIncludeDepth" : 2
    },
    "recommendation" : {
      "primaryEntity" : "Customer",
      "targetService" : "DYNAMODB",
      "tableName" : "CustomerData",
      "partitionKey" : {
        "attribute" : "customerId",
        "type" : "S",
        "description" : "Unique customer identifier",
        "examples" : [ "CUST123", "CUST456" ]
      },
      "sortKey" : {
        "attribute" : "entityType#timestamp",
        "type" : "S",
        "description" : "Composite key for entity type and timestamp",
        "examples" : [ "PROFILE#2024-01-15", "ORDER#2024-01-16" ]
      },
      "globalSecondaryIndexes" : [ {
        "indexName" : "EmailIndex",
        "partitionKey" : "email",
        "sortKey" : "customerId",
        "purpose" : "Query customers by email"
      } ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: High-volume key-based access patterns\n\nTable Design:\n- Table Name: CustomerData\n- Partition Key: customerId (S)\n- Sort Key: entityType#timestamp (S)\n\nSingle Table Design:\n- Shared Table: ApplicationData\n- Entity Discriminator: entityType\n- Rationale: Customer and Order entities are always accessed together\n\nAccess Patterns:\n- Get customer by ID: Retrieve customer profile\n",
      "designRationale" : {
        "denormalizationStrategy" : "Single-table design combining Customer with frequently co-accessed Order and OrderItem entities based on 85% of co-access patterns",
        "keyDesignJustification" : "CustomerId as partition key enables efficient customer lookups; composite sort key with entityType allows storing multiple entity types while maintaining query efficiency",
        "relationshipHandling" : "1:N Customer-Order relationship preserved through sort key design; Order items embedded as nested documents to reduce joins",
        "performanceOptimizations" : "GSI on email optimizes customer lookup pattern; sparse index on orderStatus reduces scan costs for order queries",
        "accessPatternAnalysis" : "Analysis shows 95% of queries retrieve customer with recent orders, supporting single-table design. Read-heavy workload (10:1) favors denormalization",
        "tradeoffsConsidered" : [ "Single table reduces join complexity but increases item size", "Denormalization improves read performance but requires careful update orchestration", "GSI costs offset by elimination of join operations" ]
      }
    }
  }, {
    "primaryEntity" : "CustomerProfile",
    "relatedEntities" : [ "Customer" ],
    "complexity" : "LOW",
    "score" : 147,
    "reason" : "",
    "currentPattern" : {
      "eagerLoadingFrequency" : 0,
      "readWriteRatio" : 0.0,
      "averageIncludeDepth" : 1
    },
    "recommendation" : {
      "primaryEntity" : "CustomerProfile",
      "targetService" : "DYNAMODB",
      "tableName" : "ApplicationData",
      "partitionKey" : {
        "attribute" : "customerId",
        "type" : "S",
        "description" : "Unique customer identifier, shared with Customer entity",
        "examples" : [ "CUST789", "CUST101" ]
      },
      "sortKey" : {
        "attribute" : "entityType#timestamp",
        "type" : "S",
        "description" : "Composite key for entity type and timestamp, shared with Customer entity",
        "examples" : [ "PROFILE#2024-02-20", "PROFILE#2024-02-21" ]
      },
      "globalSecondaryIndexes" : [ ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: Low complexity and high co-access frequency with Customer entity\n\nTable Design:\n- Table Name: ApplicationData\n- Partition Key: customerId (S)\n- Sort Key: entityType#timestamp (S)\n\nSingle Table Design:\n- Shared Table: ApplicationData\n- Entity Discriminator: entityType\n- Rationale: Shared access pattern with Customer entity\n",
      "designRationale" : {
        "denormalizationStrategy" : "Included in the Customer entity's single-table design to leverage co-access patterns and simplify queries",
        "keyDesignJustification" : "Using customerId as partition key for consistent access pattern across Customer and CustomerProfile entities",
        "relationshipHandling" : "Direct relationship with Customer entity is naturally modeled in a single-table design",
        "performanceOptimizations" : "Leveraging the existing CustomerData table design to minimize additional overhead",
        "accessPatternAnalysis" : "Given the high co-access rate with Customer, including CustomerProfile in the same table optimizes for read performance",
        "tradeoffsConsidered" : [ "Increased complexity in managing single table for multiple entities", "Potential for larger item sizes, but offset by reduced need for joins and separate queries" ]
      }
    }
  }, {
    "primaryEntity" : "Order",
    "relatedEntities" : [ "OrderItems", "Customer", "OrderItem" ],
    "complexity" : "MEDIUM",
    "score" : 70,
    "reason" : "Eager loading patterns (3 occurrences); Always loaded with: OrderItems, Customer; Read-heavy access pattern (ratio: 5.0:1); Complex eager loading patterns (1 complex queries)",
    "currentPattern" : {
      "eagerLoadingFrequency" : 3,
      "readWriteRatio" : 5.0,
      "averageIncludeDepth" : 2
    },
    "recommendation" : {
      "primaryEntity" : "Order",
      "targetService" : "DYNAMODB",
      "tableName" : "ApplicationData",
      "partitionKey" : {
        "attribute" : "customerId",
        "type" : "S",
        "description" : "Unique customer identifier, to align with Customer entity access patterns",
        "examples" : [ "CUST234", "CUST567" ]
      },
      "sortKey" : {
        "attribute" : "entityType#orderId",
        "type" : "S",
        "description" : "Composite key for entity type and unique order identifier",
        "examples" : [ "ORDER#ORD123", "ORDER#ORD456" ]
      },
      "globalSecondaryIndexes" : [ ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: Medium complexity due to nested relationships and read-heavy patterns\n\nTable Design:\n- Table Name: ApplicationData\n- Partition Key: customerId (S)\n- Sort Key: entityType#orderId (S)\n\nSingle Table Design:\n- Shared Table: ApplicationData\n- Entity Discriminator: entityType\n- Rationale: Orders are frequently accessed with Customer, supporting a unified table structure\n",
      "designRationale" : {
        "denormalizationStrategy" : "Orders included with Customer in a single-table design to optimize for frequent co-access patterns",
        "keyDesignJustification" : "CustomerId as partition key supports efficient retrieval of orders by customer; entityType#orderId sort key enables order-specific queries",
        "relationshipHandling" : "Embedding OrderItems within Order records to minimize read operations and simplify data retrieval",
        "performanceOptimizations" : "Avoiding separate tables for Orders and OrderItems to reduce query complexity and improve read efficiency",
        "accessPatternAnalysis" : "High read-to-write ratio and frequent access with Customer entity justify single-table design",
        "tradeoffsConsidered" : [ "Potential increase in item size due to embedding OrderItems, but benefits from reduced query complexity", "Single-table design complexity versus ease of access and performance gains" ]
      }
    }
  }, {
    "primaryEntity" : "OrderItem",
    "relatedEntities" : [ "Order", "Customer" ],
    "complexity" : "LOW",
    "score" : 42,
    "reason" : "",
    "currentPattern" : {
      "eagerLoadingFrequency" : 0,
      "readWriteRatio" : 0.0,
      "averageIncludeDepth" : 1
    },
    "recommendation" : {
      "primaryEntity" : "OrderItem",
      "targetService" : "DYNAMODB",
      "tableName" : "ApplicationData",
      "partitionKey" : {
        "attribute" : "customerId",
        "type" : "S",
        "description" : "Aligns with Customer and Order for unified access patterns",
        "examples" : [ "CUST890", "CUST012" ]
      },
      "sortKey" : {
        "attribute" : "entityType#orderId#orderItemId",
        "type" : "S",
        "description" : "Composite key for entity type, order ID, and unique order item identifier",
        "examples" : [ "ORDERITEM#ORD123#ITEM456", "ORDERITEM#ORD789#ITEM012" ]
      },
      "globalSecondaryIndexes" : [ ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: Low complexity, but integral to Order processing and retrieval\n\nTable Design:\n- Table Name: ApplicationData\n- Partition Key: customerId (S)\n- Sort Key: entityType#orderId#orderItemId (S)\n\nSingle Table Design:\n- Shared Table: ApplicationData\n- Entity Discriminator: entityType\n- Rationale: OrderItems are part of Orders, necessitating inclusion in the unified table structure\n",
      "designRationale" : {
        "denormalizationStrategy" : "Embedding OrderItems within Orders to streamline data retrieval and reduce the need for separate queries",
        "keyDesignJustification" : "Composite sort key allows for efficient retrieval of specific OrderItems within an Order",
        "relationshipHandling" : "Maintains the MANY_TO_ONE relationship with Orders within a single table, simplifying data management",
        "performanceOptimizations" : "Reduces the need for separate tables and queries, optimizing for read operations",
        "accessPatternAnalysis" : "Given the integral role of OrderItems in order processing, embedding within Orders supports efficient access",
        "tradeoffsConsidered" : [ "Increased complexity in item structure, but with significant benefits in query efficiency", "Embedding limits flexibility for OrderItem updates, but aligns with the primary access patterns" ]
      }
    }
  }, {
    "primaryEntity" : "Category",
    "relatedEntities" : [ "Products" ],
    "complexity" : "LOW",
    "score" : 21,
    "reason" : "Eager loading patterns (1 occurrences); Always loaded with: Products",
    "currentPattern" : {
      "eagerLoadingFrequency" : 1,
      "readWriteRatio" : 3.0,
      "averageIncludeDepth" : 1
    },
    "recommendation" : {
      "primaryEntity" : "Category",
      "targetService" : "DYNAMODB",
      "tableName" : "ProductData",
      "partitionKey" : {
        "attribute" : "categoryId",
        "type" : "S",
        "description" : "Unique category identifier",
        "examples" : [ "CAT123", "CAT456" ]
      },
      "sortKey" : {
        "attribute" : "entityType#name",
        "type" : "S",
        "description" : "Composite key for entity type and category name",
        "examples" : [ "CATEGORY#Electronics", "CATEGORY#Books" ]
      },
      "globalSecondaryIndexes" : [ ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: Low complexity and specific access patterns\n\nTable Design:\n- Table Name: ProductData\n- Partition Key: categoryId (S)\n- Sort Key: entityType#name (S)\n",
      "designRationale" : {
        "denormalizationStrategy" : "Maintained as a separate entity due to distinct access patterns from core Customer-Order data",
        "keyDesignJustification" : "CategoryId as partition key supports direct lookups; entityType#name sort key enables efficient category name queries",
        "relationshipHandling" : "ONE_TO_MANY relationship with Products managed through category references within Product items",
        "performanceOptimizations" : "Separate table optimizes category-specific queries without impacting the performance of the unified Customer-Order table",
        "accessPatternAnalysis" : "Distinct access patterns and lower co-access frequency with Customer and Order entities",
        "tradeoffsConsidered" : [ "Separate table increases complexity but allows for optimized category management and queries", "Maintains flexibility for category-specific updates and queries without impacting the primary Customer-Order data model" ]
      }
    }
  }, {
    "primaryEntity" : "Product",
    "relatedEntities" : [ "Categories" ],
    "complexity" : "LOW",
    "score" : 21,
    "reason" : "Eager loading patterns (1 occurrences); Always loaded with: Categories",
    "currentPattern" : {
      "eagerLoadingFrequency" : 1,
      "readWriteRatio" : 3.0,
      "averageIncludeDepth" : 1
    },
    "recommendation" : {
      "primaryEntity" : "Product",
      "targetService" : "DYNAMODB",
      "tableName" : "ProductData",
      "partitionKey" : {
        "attribute" : "productId",
        "type" : "S",
        "description" : "Unique product identifier",
        "examples" : [ "PROD123", "PROD456" ]
      },
      "sortKey" : {
        "attribute" : "entityType#category",
        "type" : "S",
        "description" : "Composite key for entity type and category association",
        "examples" : [ "PRODUCT#Electronics", "PRODUCT#Books" ]
      },
      "globalSecondaryIndexes" : [ ],
      "schemaDesign" : "Target Service: DynamoDB\nJustification: Low complexity with specific access patterns related to Categories\n\nTable Design:\n- Table Name: ProductData\n- Partition Key: productId (S)\n- Sort Key: entityType#category (S)\n",
      "designRationale" : {
        "denormalizationStrategy" : "Maintained as a separate entity due to distinct access patterns from core Customer-Order data",
        "keyDesignJustification" : "ProductId as partition key supports direct lookups; entityType#category sort key enables efficient queries by category",
        "relationshipHandling" : "ONE_TO_MANY relationship with Categories reflected in sort key, facilitating category-based product queries",
        "performanceOptimizations" : "Separate table for Products allows for efficient management and querying of product data without impacting Customer-Order table performance",
        "accessPatternAnalysis" : "Product queries often involve category filtering, justifying a separate table to optimize these access patterns",
        "tradeoffsConsidered" : [ "Separate table increases complexity but allows for optimized product management and queries", "Maintains flexibility for product-specific updates and queries without impacting the primary Customer-Order data model" ]
      }
    }
  } ],
  "riskAssessment" : {
    "highRiskEntities" : [ ],
    "potentialDataLoss" : [ ],
    "performanceImpacts" : [ ]
  }
}